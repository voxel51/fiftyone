"""
Materialized views.

| Copyright 2017-2024, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
from copy import deepcopy

from bson import ObjectId

import eta.core.utils as etau

import fiftyone.core.sample as fos
import fiftyone.core.odm as foo
import fiftyone.core.utils as fou
import fiftyone.core.view as fov


class MaterializedSampleView(fos.SampleView):
    """A sample in a :class:`MaterializedView`.

    :class:`MaterializedSampleView` instances should not be created manually;
    they are generated by iterating over :class:`MaterializedView` instances.

    Args:
        doc: a :class:`fiftyone.core.odm.DatasetSampleDocument`
        view: the :class:`MaterializedView` that the sample belongs to
        selected_fields (None): a set of field names that this view is
            restricted to
        excluded_fields (None): a set of field names that are excluded from
            this view
        filtered_fields (None): a set of field names of list fields that are
            filtered in this view
    """

    def _save(self, deferred=False):
        sample_ops, frame_ops = super()._save(deferred=deferred)

        if not deferred:
            self._view._sync_source_sample(self)

        return sample_ops, frame_ops


class MaterializedView(fov.DatasetView):
    """A :class:`fiftyone.core.view.DatasetView` of samples from a materialized
    view.

    Samples retrieved from materialized views are returned as
    :class:`MaterializedSampleView` objects.

    Args:
        source_collection: the
            :class:`fiftyone.core.collections.SampleCollection` from which this
            view was created
        materialize_stage: the :class:`fiftyone.core.stages.Materialize` stage
            that created this view
        materialized_dataset: the :class:`fiftyone.core.dataset.Dataset` that
            serves the samples in this view
    """

    __slots__ = (
        "_source_collection",
        "_materialize_stage",
        "_materialized_dataset",
        "__stages",
        "__media_type",
        "__name",
    )

    def __init__(
        self,
        source_collection,
        materialize_stage,
        materialized_dataset,
        _stages=None,
        _media_type=None,
        _name=None,
    ):
        if _stages is None:
            _stages = []

        self._source_collection = source_collection
        self._materialize_stage = materialize_stage
        self._materialized_dataset = materialized_dataset
        self.__stages = _stages
        self.__media_type = _media_type
        self.__name = _name

    def __copy__(self):
        return self.__class__(
            self._source_collection,
            deepcopy(self._materialize_stage),
            self._materialized_dataset,
            _stages=deepcopy(self.__stages),
            _media_type=self.__media_type,
            _name=self.__name,
        )

    @property
    def _base_view(self):
        return self.__class__(
            self._source_collection,
            self._materialize_stage,
            self._materialized_dataset,
        )

    @property
    def _dataset(self):
        return self._materialized_dataset

    @property
    def _root_dataset(self):
        return self._source_collection._root_dataset

    @property
    def _sample_cls(self):
        return MaterializedSampleView

    @property
    def _stages(self):
        return self.__stages

    @property
    def _all_stages(self):
        return (
            self._source_collection.view()._all_stages
            + [self._materialize_stage]
            + self.__stages
        )

    @property
    def name(self):
        return self.__name

    @property
    def is_saved(self):
        return self.__name is not None

    @property
    def media_type(self):
        if self.__media_type is not None:
            return self.__media_type

        return self._dataset.media_type

    def _set_name(self, name):
        self.__name = name

    def _set_media_type(self, media_type):
        self.__media_type = media_type

    def _tag_labels(self, tags, label_field, ids=None, label_ids=None):
        ids, label_ids = super()._tag_labels(
            tags, label_field, ids=ids, label_ids=label_ids
        )

        self._source_collection._tag_labels(
            tags, label_field, ids=ids, label_ids=label_ids
        )

    def _untag_labels(self, tags, label_field, ids=None, label_ids=None):
        ids, label_ids = super()._untag_labels(
            tags, label_field, ids=ids, label_ids=label_ids
        )

        self._source_collection._untag_labels(
            tags, label_field, ids=ids, label_ids=label_ids
        )

    def set_values(self, field_name, *args, **kwargs):
        # The `set_values()` operation could change the contents of this view,
        # so we first record the sample IDs that need to be synced
        if self._stages:
            ids = self.values("id")
        else:
            ids = None

        super().set_values(field_name, *args, **kwargs)

        field = field_name.split(".", 1)[0]
        self._sync_source(fields=[field], ids=ids)
        self._sync_source_field_schema(field_name)

    def set_label_values(self, field_name, *args, **kwargs):
        super().set_label_values(field_name, *args, **kwargs)

        self._source_collection.set_label_values(field_name, *args, **kwargs)

    def save(self, fields=None):
        """Saves the samples in this view to the underlying dataset.

        .. note::

            This method is not a :class:`fiftyone.core.stages.ViewStage`;
            it immediately writes the requested changes to the underlying
            dataset.

        .. warning::

            This will permanently delete any omitted or filtered contents from
            the samples of the source dataset.

        Args:
            fields (None): an optional field or list of fields to save. If
                specified, only these fields are overwritten
        """
        if etau.is_str(fields):
            fields = [fields]

        super().save(fields=fields)

        self._sync_source(fields=fields)

    def keep(self):
        """Deletes all samples that are **not** in this view from the underlying
        dataset.

        .. note::

            This method is not a :class:`fiftyone.core.stages.ViewStage`;
            it immediately writes the requested changes to the underlying
            dataset.
        """

        # The `keep()` operation below will delete samples, so we must sync
        # deletions to the source dataset first
        self._sync_source(update=False, delete=True)

        super().keep()

    def keep_fields(self):
        """Deletes any sample fields that have been excluded in this view from
        the samples of the underlying dataset.

        .. note::

            This method is not a :class:`fiftyone.core.stages.ViewStage`;
            it immediately writes the requested changes to the underlying
            dataset.
        """
        self._sync_source_keep_fields()

        super().keep_fields()

    def reload(self):
        """Reloads the view.

        Note that :class:`MaterializedSampleView` instances are not singletons,
        so any in-memory samples extracted from this view will not be updated
        by calling this method.
        """
        self._source_collection.reload()

        #
        # Regenerate the materialized dataset
        #
        # This assumes that calling `load_view()` when the current materialized
        # dataset has been deleted will cause a new one to be generated
        #
        self._materialized_dataset.delete()
        _view = self._materialize_stage.load_view(self._source_collection)
        self._materialized_dataset = _view._materialized_dataset

        super().reload()

    def _set_labels(self, field_name, sample_ids, label_docs):
        super()._set_labels(field_name, sample_ids, label_docs)

        self._sync_source(fields=[field_name], ids=sample_ids)

    def _delete_labels(self, ids, fields=None):
        super()._delete_labels(ids, fields=fields)

        self._source_collection._delete_labels(ids, fields=fields)

    def _sync_source_sample(self, sample):
        self._sync_source_schema()

        dst_dataset = self._source_collection._root_dataset

        match = {"_id": sample._id}
        updates = sample.to_mongo_dict()

        dst_dataset._sample_collection.update_one(match, {"$set": updates})

    def _sync_source(self, fields=None, ids=None, update=True, delete=False):
        has_frame_fields = self._has_frame_fields()

        if has_frame_fields and fields is not None:
            sample_fields, frame_fields = fou.split_frame_fields(fields)
        else:
            sample_fields, frame_fields = fields, None

        dst_dataset = self._source_collection._root_dataset

        if update:
            self._sync_source_schema(fields=fields)

            if fields is None or sample_fields:
                pipeline = []

                if ids is not None:
                    pipeline.append(
                        {
                            "$match": {
                                "_id": {"$in": [ObjectId(_id) for _id in ids]}
                            }
                        }
                    )

                if sample_fields is not None:
                    project = {f: True for f in sample_fields}
                    project["_id"] = True
                    pipeline.append({"$project": project})

                pipeline.append(
                    {
                        "$merge": {
                            "into": dst_dataset._sample_collection_name,
                            "on": "_id",
                            "whenMatched": "merge",
                            "whenNotMatched": "discard",
                        }
                    }
                )

                self._materialized_dataset._aggregate(pipeline=pipeline)

            if has_frame_fields and (fields is None or frame_fields):
                pipeline = []
                post_pipeline = []

                if ids is not None:
                    pipeline.append(
                        {
                            "$match": {
                                "_id": {"$in": [ObjectId(_id) for _id in ids]}
                            }
                        }
                    )

                if frame_fields is not None:
                    project = {f: True for f in frame_fields}
                    project["_sample_id"] = True
                    project["frame_number"] = True
                    post_pipeline.append({"$project": project})

                post_pipeline.append(
                    {
                        "$merge": {
                            "into": dst_dataset._frame_collection_name,
                            "on": ["_sample_id", "frame_number"],
                            "whenMatched": "merge",
                            "whenNotMatched": "discard",
                        }
                    }
                )

                self._materialized_dataset._aggregate(
                    pipeline=pipeline,
                    frames_only=True,
                    post_pipeline=post_pipeline,
                )

        if delete:
            sample_ids = self._materialized_dataset.exclude(self).values("id")
            dst_dataset._clear(sample_ids=sample_ids)

    def _sync_source_field_schema(self, path):
        field = self.get_field(path)
        if field is None:
            return

        _path, is_frame_field = self._handle_frame_field(path)

        dst_dataset = self._source_collection._dataset
        if is_frame_field:
            dst_dataset._merge_frame_field_schema({_path: field})
        else:
            dst_dataset._merge_sample_field_schema({path: field})

        if self._source_collection._is_generated:
            self._source_collection._sync_source_field_schema(path)

    def _sync_source_schema(self, fields=None, delete=False):
        has_frame_fields = self._has_frame_fields()

        if has_frame_fields and fields is not None:
            sample_fields, frame_fields = fou.split_frame_fields(fields)
        else:
            sample_fields, frame_fields = fields, None

        dst_dataset = self._source_collection._root_dataset
        src_schema = self._source_collection.get_field_schema()

        if delete:
            schema = self.get_field_schema()
        else:
            schema = self._materialized_dataset.get_field_schema()

        if has_frame_fields:
            if delete:
                frame_schema = self.get_frame_field_schema()
            else:
                frame_schema = (
                    self._materialized_dataset.get_frame_field_schema()
                )

            src_frame_schema = self._source_collection.get_frame_field_schema()

        add_sample_fields = []
        del_sample_fields = []
        add_frame_fields = []
        del_frame_fields = []

        if fields is not None:
            # We're syncing specific fields; if they are not present in source
            # collection, add them

            for field_name in sample_fields:
                if field_name not in src_schema:
                    add_sample_fields.append(field_name)
        else:
            # We're syncing all fields; add any missing fields to source
            # collection and, if requested, delete any source fields that
            # aren't in this view

            for field_name in schema.keys():
                if field_name not in src_schema:
                    add_sample_fields.append(field_name)

            if delete:
                for field_name in src_schema.keys():
                    if field_name not in schema:
                        del_sample_fields.append(field_name)

        if has_frame_fields:
            if fields is not None:
                # We're syncing specific fields; if they are not present in
                # source collection, add them

                for field_name in frame_fields:
                    if field_name not in src_frame_schema:
                        add_frame_fields.append(field_name)
            else:
                # We're syncing all fields; add any missing fields to source
                # collection and, if requested, delete any source fields that
                # aren't in this view

                for field_name in frame_schema.keys():
                    if field_name not in src_frame_schema:
                        add_frame_fields.append(field_name)

                if delete:
                    for field_name in src_frame_schema.keys():
                        if field_name not in frame_schema:
                            del_frame_fields.append(field_name)

        for field_name in add_sample_fields:
            field_kwargs = foo.get_field_kwargs(schema[field_name])
            dst_dataset.add_sample_field(field_name, **field_kwargs)

        for field_name in add_frame_fields:
            field_kwargs = foo.get_field_kwargs(frame_schema[field_name])
            dst_dataset.add_frame_field(field_name, **field_kwargs)

        if delete and del_sample_fields:
            dst_dataset.delete_sample_fields(del_sample_fields)

        if delete and del_frame_fields:
            dst_dataset.delete_frame_fields(del_frame_fields)

    def _sync_source_keep_fields(self):
        schema = self.get_field_schema()
        src_schema = self._source_collection.get_field_schema()

        if self._has_frame_fields():
            p = self._FRAMES_PREFIX

            frame_schema = self.get_frame_field_schema()
            schema.update({p + k: v for k, v in frame_schema.items()})

            src_frame_schema = self._source_collection.get_frame_field_schema()
            src_schema.update({p + k: v for k, v in src_frame_schema.items()})

        del_fields = set(src_schema.keys()) - set(schema.keys())
        if del_fields:
            self._source_collection.exclude_fields(del_fields).keep_fields()


def materialize_view(sample_collection, name=None, persistent=False):
    """Creates a dataset that contains a materialized copy of the given
    collection.

    Args:
        sample_collection: a
            :class:`fiftyone.core.collections.SampleCollection`
        name (None): a name for the dataset
        persistent (False): whether the dataset should persist in the database
            after the session terminates

    Returns:
        a :class:`fiftyone.core.dataset.Dataset`
    """
    dataset = sample_collection._root_dataset
    if isinstance(sample_collection, fov.DatasetView):
        view = sample_collection
    else:
        # Materializing an entire dataset is a bit weird, but we'll allow it
        view = sample_collection.view()

    return dataset._clone(
        name=name, persistent=persistent, view=view, materialized=True
    )
